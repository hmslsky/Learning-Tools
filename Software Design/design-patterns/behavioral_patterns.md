# 行为型模式 (Behavioral Patterns)

行为型模式关注对象之间的责任分配，它们描述对象之间如何协作以及如何分配职责。本文件整合了所有行为型设计模式的内容。

## 目录
1. [责任链模式 (Chain of Responsibility)](#责任链模式-chain-of-responsibility)
2. [命令模式 (Command)](#命令模式-command)
3. [解释器模式 (Interpreter)](#解释器模式-interpreter)
4. [迭代器模式 (Iterator)](#迭代器模式-iterator)
5. [中介者模式 (Mediator)](#中介者模式-mediator)
6. [备忘录模式 (Memento)](#备忘录模式-memento)
7. [观察者模式 (Observer)](#观察者模式-observer)
8. [状态模式 (State)](#状态模式-state)
9. [策略模式 (Strategy)](#策略模式-strategy)
10. [模板方法模式 (Template Method)](#模板方法模式-template-method)
11. [访问者模式 (Visitor)](#访问者模式-visitor)

## 责任链模式 (Chain of Responsibility)

责任链模式为请求创建一个接收者对象的链，使多个对象都有机会处理这个请求。

### 特点
- 降低耦合度
- 增强了给对象指派职责的灵活性
- 不保证请求一定被处理

### 实现方式
1. 抽象处理者
2. 具体处理者
3. 客户端

### 应用场景
- 有多个对象可以处理同一个请求
- 不明确指定接收者
- 动态指定一组对象处理请求

## 命令模式 (Command)

命令模式将请求封装成对象，使发出请求的责任和执行请求的责任分割开。

### 特点
- 将请求封装成对象
- 支持撤销操作
- 支持日志记录

### 实现方式
1. 命令接口
2. 具体命令
3. 调用者
4. 接收者

### 应用场景
- 需要将请求发送者和接收者解耦
- 需要支持命令的排队执行
- 需要支持命令的撤销和重做

## 解释器模式 (Interpreter)

解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

### 特点
- 容易改变和扩展文法
- 实现文法较为容易
- 执行效率较低

### 实现方式
1. 抽象表达式
2. 终结符表达式
3. 非终结符表达式
4. 环境类

### 应用场景
- 需要解释一个简单的语法规则
- 需要频繁地解释一些表达式
- 需要扩展语言的语法

## 迭代器模式 (Iterator)

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

### 特点
- 支持以不同的方式遍历一个聚合对象
- 简化了聚合类的接口
- 在同一个聚合上可以有多个遍历

### 实现方式
1. 迭代器接口
2. 具体迭代器
3. 聚合接口
4. 具体聚合

### 应用场景
- 需要访问一个聚合对象的内容
- 需要支持多种遍历方式
- 需要为遍历不同的聚合结构提供一个统一的接口

## 中介者模式 (Mediator)

中介者模式用一个中介对象来封装一系列的对象交互，使各对象不需要显式地相互引用。

### 特点
- 降低了对象之间的耦合度
- 简化了对象之间的交互
- 集中控制交互

### 实现方式
1. 中介者接口
2. 具体中介者
3. 同事类

### 应用场景
- 对象之间存在复杂的通信
- 想定制一个分布在多个类中的行为
- 想避免对象之间的直接耦合

## 备忘录模式 (Memento)

备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

### 特点
- 保持封装边界
- 简化了发起人
- 可能产生大量的备忘录对象

### 实现方式
1. 发起人
2. 备忘录
3. 管理者

### 应用场景
- 需要保存对象在某一时刻的状态
- 需要实现撤销操作
- 需要实现历史记录功能

## 观察者模式 (Observer)

观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

### 特点
- 支持广播通信
- 符合开闭原则
- 可能引起不必要的更新

### 实现方式
1. 抽象主题
2. 具体主题
3. 抽象观察者
4. 具体观察者

### 应用场景
- 需要建立一种一对多的依赖关系
- 需要实现事件处理系统
- 需要实现消息订阅系统

## 状态模式 (State)

状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

### 特点
- 封装了转换规则
- 枚举可能的状态
- 将所有与状态相关的行为封装在一个类中

### 实现方式
1. 环境类
2. 抽象状态
3. 具体状态

### 应用场景
- 对象的行为取决于其状态
- 代码中包含大量与状态有关的条件语句
- 需要消除庞大的条件分支语句

## 策略模式 (Strategy)

策略模式定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。

### 特点
- 算法可以自由切换
- 避免使用多重条件判断
- 扩展性良好

### 实现方式
1. 抽象策略
2. 具体策略
3. 环境类

### 应用场景
- 系统中有多个算法
- 算法有相似的行为
- 需要动态切换算法

## 模板方法模式 (Template Method)

模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

### 特点
- 代码复用
- 扩展性良好
- 符合开闭原则

### 实现方式
1. 抽象类
2. 具体子类

### 应用场景
- 一次性实现一个算法的不变部分
- 各子类中公共的行为应被提取出来
- 控制子类扩展

## 访问者模式 (Visitor)

访问者模式表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

### 特点
- 增加新的操作很容易
- 将相关行为集中在一起
- 破坏封装性

### 实现方式
1. 访问者接口
2. 具体访问者
3. 元素接口
4. 具体元素

### 应用场景
- 对象结构相对稳定
- 需要经常定义新的操作
- 需要对对象结构中的对象进行很多不同的操作 