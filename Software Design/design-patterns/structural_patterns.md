# 结构型模式 (Structural Patterns)

结构型模式关注类和对象的组合，它们通过组合类和对象来获得更大的结构。本文件整合了所有结构型设计模式的内容。

## 目录
1. [适配器模式 (Adapter)](#适配器模式-adapter)
2. [桥接模式 (Bridge)](#桥接模式-bridge)
3. [组合模式 (Composite)](#组合模式-composite)
4. [装饰模式 (Decorator)](#装饰模式-decorator)
5. [外观模式 (Facade)](#外观模式-facade)
6. [享元模式 (Flyweight)](#享元模式-flyweight)
7. [代理模式 (Proxy)](#代理模式-proxy)

## 适配器模式 (Adapter)

适配器模式将一个类的接口转换成客户希望的另外一个接口，使原本由于接口不兼容而不能一起工作的类可以一起工作。

### 特点
- 将不兼容的接口转换为可兼容的接口
- 提高类的复用性
- 增加类的透明度

### 实现方式
1. 类适配器
2. 对象适配器
3. 接口适配器

### 应用场景
- 系统需要使用现有的类，而此类的接口不符合系统的需要
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类一起工作
- 需要统一多个类的接口

## 桥接模式 (Bridge)

桥接模式将抽象部分与实现部分分离，使它们都可以独立地变化。

### 特点
- 抽象和实现分离
- 优秀的扩展能力
- 实现细节对客户透明

### 实现方式
1. 抽象类
2. 实现类接口
3. 具体实现类
4. 具体抽象类

### 应用场景
- 需要在抽象和实现之间建立更灵活的关系
- 需要避免抽象和实现之间的永久绑定
- 需要支持多种实现方式

## 组合模式 (Composite)

组合模式将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

### 特点
- 表示对象的部分-整体层次结构
- 客户端可以统一地使用组合结构和单个对象
- 容易添加新类型的组件

### 实现方式
1. 组件接口
2. 叶子节点
3. 组合节点

### 应用场景
- 需要表示对象的部分-整体层次结构
- 希望用户忽略组合对象与单个对象的不同
- 需要统一处理组合对象和单个对象

## 装饰模式 (Decorator)

装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

### 特点
- 动态地给对象添加职责
- 比继承更灵活
- 避免类爆炸

### 实现方式
1. 组件接口
2. 具体组件
3. 装饰器基类
4. 具体装饰器

### 应用场景
- 需要动态地给对象添加职责
- 需要撤销职责
- 需要组合多个职责

## 外观模式 (Facade)

外观模式为子系统中的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 特点
- 为复杂的子系统提供一个简单的接口
- 降低子系统与客户之间的耦合度
- 提高子系统的独立性

### 实现方式
1. 外观类
2. 子系统类

### 应用场景
- 需要为复杂的子系统提供一个简单的接口
- 需要将子系统与客户解耦
- 需要构建层次结构的子系统

## 享元模式 (Flyweight)

享元模式运用共享技术有效地支持大量细粒度的对象。

### 特点
- 减少对象数量
- 节省内存空间
- 提高系统性能

### 实现方式
1. 享元工厂
2. 抽象享元
3. 具体享元
4. 非享元部分

### 应用场景
- 系统有大量相似对象
- 需要缓冲池的场景
- 对象的大部分状态都可以外部化

## 代理模式 (Proxy)

代理模式为其他对象提供一种代理以控制对这个对象的访问。

### 特点
- 控制对对象的访问
- 增加额外的功能
- 实现延迟加载

### 实现方式
1. 抽象主题
2. 真实主题
3. 代理类

### 应用场景
- 远程代理
- 虚拟代理
- 保护代理
- 智能引用 